# 빅오(O, big-O)
입력값이 무한대로 향할때 함수의 상한을 설명하는 수학적 표기 방법이다.
시간복잡도를 나타낼 때 사용된다. 
* O(1) : 입력값이 아무리 커도 실행 시간은 일정하다
* O(log n) : 매우 큰 입력값에도 크게 영향을 받지 않는다
* O(n) : 입력값만큼 실행시간에 영향을 받는다. 
* O(n log n) : 병렬 정렬을 비롯한 대부분의 효율 좋은 정렬 알고리즘이 이에 속한다. 적어도 모든 수에 대해서 한 번 이상을 비교해야 하는 비교 기반 정렬 알고리즘은 아무리 좋은 알고리즘도 O(n log n) 보다 빠를 수 없다. 
* O(n^2) : 버블 정렬이 이에 해당한다. 
* O(2^n) : 피보나치 수를 재귀적으로 계산하는 알고리즘이 이에 해당한다. 
* O(n!) : 각 도시를 방문하고 돌아오는 가장 짧은 경로를 찾는 외판원 문제를 브루트 포스로 풀이할 때가 이에 해당한다. 

참고: https://www.bigocheatsheet.com

## 상한과 최악
빅오는 상한을 의미한다. 빅오 표기법은 정확하게 쓰기에는 너무 길고 복잡한 함수를 적당히 정확하게 표현하는 방법일 뿐이다. 

## 분할 상환 분석
시간 또는 메모리를 분석하는 알고리즘의 복잡도를 계산할 때, 알고리즘 전체를 보지 않고 최악의 경우만을 살펴보는 것이 지나치게 비관적이라는 이유로 분할 상환 방법이 등장하는 계기가 됐다.

최악의 경우를 여러 번에 걸쳐 골고루 나눠주는 형태로 알고리즘의 사시 복잡도를 계산할 수 있다. 

## 병렬화
일부 알고리즘은 병렬화를 통해서 실행 속도를 높일 수 있다. 

# 자료형
## 파이썬 자료형
* None
* 숫자
    * 정수형
	  * 정수
	  * 불리언
	* 실수
* 시퀀스
	* 불변
	  * 문자열
	  * 튜플
	  * 바이트
	* 가변
	  * 리스트
* 집합형
	* 집합
* 매핑
	* 딕셔너리

### 숫자
파이썬에서는 숫자 정수형으로 int만을 제공한다. int는 임의 정밀도이다. 

### 매핑 
key, value의 쌍을 이루는 자료형이다. 

### 집합
중복을 허용하지 않으며 입력 순서가 유지되지 않는다.

빈 집합 선언
``` 
>>> a = set()
>>> a
set()
>>> type(a)
<class 'set'>
``` 
값이 포함된 집합 선언
``` python
>>> a = {'a', 'b', 'c'}
>>> type(a)
<class 'set'>
>>> a = {'a':'A', 'b':'B', 'c':'C'}
>>> type(a)
<class 'dict'>
```

### 시퀀스
``` python 
>>> a = 'abc'
>>> a = 'def'
>>> type(a)
<class 'str'>
```

``` python 
>>> a = 'abc'
>>> id('abc')
1833388002672
>>> id(a)
1833388002672
>>> a = 'def'
>>> id('def')
1833388407216
>>> id(a)
1833388407216
```
## 원시타입
* C, C++, Java는 원시타입을 지원한다.
## 객체
* C++, Java는 객체를 지원한다. 
* 파이썬은 객체만을 지원한다
### 불변 객체 
값이 설정된 후에는 변경이 될 수 없다. 

* bool, int, float, tuple, str

> tuple(튜플)은 불변한 순서가 있는 객체의 집합입니다. list형과 비슷하지만 한 번 생성되면 값을 변경할 수 없습니다.

``` python 
>>> 10
>>> a = 10
>>> b = a
>>> id(10), id(a), id(b)
(140714134083520, 140714134083520, 140714134083520)
```
### 가변 객체 
값이 설정된 후에도 변경이 가능하다. 

* list, set, dict
``` python 
>>> a = [1, 2, 3, 4, 5]
>>> b = a
>>> b
[1, 2, 3, 4, 5]
>>> a[2] = 4
>>> a
[1, 2, 4, 4, 5]
>>> b
[1, 2, 4, 4, 5]
```

### 속도
원시타입이 속도가 빠르다
